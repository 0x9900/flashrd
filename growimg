#!/bin/sh
#
# Chris Cappuccio <chris@nmedia.net>
#
# This is an example of how to create a new image, transfer the contents
# of an old image to it, and keep the user from screwing it up too bad, by
# performing some basic sanity checks.
#
# -t target-disk causes this script to write directly to a disk instead of
# a new VND image.  This may be useful if you want to write a small image
# to a large flash without overwriting the unused space (which can be rather
# slow).  This is as fast as running flashrd, without requiring
# the source files from flashrd.
#
# This script tries to keep everything scaled to sectors, so we are less
# likely to hit the 32 bit (2^32) boundary on shell variable values (amd64
# users have no such problem.)  The sanity checks fail completely on i386
# if the source image is larger than 4GB.
#

uname=`uname -s`

[ -z "$rootdevice" ] && rootdevice=vnd3

vncfgroot() {
 c 0 vnconfig $rootdevice $1
}

vnuncfgroot() {
 c 0 vnconfig -u $rootdevice
}

###
#
# fall back

4() {
 umount -f /dev/"$device"a
}
3() {
 [ -z "$alt" ] && vnconfig -u $device
}
2() {
 umount -f /dev/"$rootdevice"a
}
1() {
 vnuncfgroot
}
0() {
 rmdir $OldDir $NewDir
 rm -f $NewImg $NewLabel
 exit 1
}

. ./flashrd.sub

if [ "$uname" != "OpenBSD" -a "$uname" != "Bitrig" ]; then
 echo Sorry, cowboy.  This script only runs on OpenBSD and similar systems.
 exit 1
fi

if [ `id -u` != 0 ]; then
 echo Sorry, mount, vnconfig, and friends require root privileges
 exit 1
fi

syntax()
{
  echo "growimg can operate in disk target mode by specifying the destination disk or it"
  echo "can create a new, resized image."
  echo
  echo "syntax: growimg <-t target-disk> <source-image-filename>"
  echo "    or: growimg <cyls> <heads> <sectors> <source-image-filename>"
}

islezero()
{
  if [ "$1" -le "0" ]; then
   syntax
   echo -n expected a value larger than 0, got \"$1\"
   if [ "$2" != "" ]; then
    echo " for $2"
   else
    echo
   fi
   exit 1
  fi
}

if [ "$1" == "-t" ]; then
 # target device specified, use its geometry
 device="$2"
 alt=/dev/"$2"c
 if [ ! -b $alt ]; then
  echo "${device}(${alt}) is an invalid disk device, not found or not block device"
  exit 1
 fi

 image=$3
else
 # geometry specified, write a new image file
 if [ ! -f "$4" ]; then
  syntax
  exit 1
 fi

 islezero $1 cylinders
 islezero $2 heads
 islezero $3 sectors

 image=$4
fi

if [ ! -f $image ]; then
  echo "Error: ${image} not found"
  exit 1
fi

if [ -z "$device" ]; then
 device=vnd0
fi

if [ -z "$alt" ]; then
 cylinders=$1
 trackscylinder=$2
 sectorstrack=$3
 bytessec=512
 totalsize=$((cylinders * trackscylinder * sectorstrack))
 sectorscylinder=$((totalsize / cylinders))
else
 # Here we use disklabel as a way to grab these values. Later versions of OpenBSD
 # always report the actual kernel-detected values and not the on-disk values

 tmplabel=`c 0 mktemp -t growimg.XXXXXX`
 c 0 disklabel $device > $tmplabel

 totalsize=`awk -F: ' /^total sectors:/ {print $2} ' $tmplabel`
 bytessec=`awk -F: ' /^bytes\/sector:/ {print $2} ' $tmplabel`
 sectorstrack=`awk -F: ' /^sectors\/track:/ {print $2} ' $tmplabel`
 sectorscylinder=`awk -F: ' /^sectors\/cylinder:/ {print $2} ' $tmplabel`
 trackscylinder=`awk -F: ' /^tracks\/cylinder:/ {print $2} ' $tmplabel`
 cylinders=`awk -F: ' /^cylinders:/ {print $2} ' $tmplabel`

 c 0 rm $tmplabel
fi

# The source image must be 4GB or less, or this will break.
imgbytes=`ls -l $image | awk ' { print $5 } '`
imgsize=$((imgbytes / bytessec))

if [ $((imgsize * bytessec)) != "$imgbytes" ]; then
 cat <<-__FluxCapacitor
	size of image $image is not divisible by $bytessec bytes/sector
	without a remainder.  this image may not be compatible with
	the media that you are installing to, or, more likely, it may
	not be a disk image at all.  either way, run flashrd to create a
	new image.
	__FluxCapacitor
 exit 1
fi

addon=$((totalsize - imgsize))

echo Image: $image
echo Image size: $((imgbytes / 1024 / 1024))MB
if [ "$bytessec" -le 1024 ]; then
 # The division is done like this to keep any 32 int from overflowing in ksh
 echo Requested size: $((totalsize / 1024 / (1024 / bytessec)))MB
 echo Size increase: $((addon / 1024 / (1024 / bytessec)))MB
fi
echo

if [ -z "$alt" ]; then
 freespace=`df . | tail -1 | awk ' { print $4 } '`

 if [ $bytessec -gt 512 ]; then
  # df reports in 512 byte sectors, so scale freespace for comparison
  # to media with different bytes/sec
  factor=$((bytessec / 512))
  freespace=$((freespace / factor))
 fi

 # The new image will not take more disk space than the old one, in fact
 # it will take less.  But it will appear to use more when dd reads it.
 # vnd will create holes in the file for the blank space so we don't have
 # to waste a bunch of disk space for megabytes of zeros!
 if [ "$imgsize" -gt "$freespace" ]; then
  echo imgsize: $imgsize sectors
  echo freespace: $freespace sectors
  echo
  echo there is not enough free disk space for the new image!
  exit 1
 fi
fi

vncfgroot $image

if [ -z "$alt" ]; then
 [ -z "$NewImg" ] && NewImg=$(c 0 mktemp -t growimg.XXXXXX)
fi
[ -z "$NewLabel" ] && NewLabel=$(c 0 mktemp -t growimg.XXXXXX)
[ -z "$OldDir" ] && OldDir=$(c 0 mktemp -t -d growimg.XXXXXX)
[ -z "$NewDir" ] && NewDir=$(c 0 mktemp -t -d growimg.XXXXXX)

c 1 mount -o rdonly /dev/"$rootdevice"a $OldDir

echo Reading current disklabel...
c 2 disklabel $rootdevice |
egrep -v "^boundstart:|^boundend:|^total sectors:|^bytes/sector:|^sectors/track:|^sectors/cylinder:|^tracks/cylinder:|^cylinders:|^  .:|^#|^. partitions:|^.. partitions:|^$" > $NewLabel

asize=$((totalsize - sectorstrack))

# This probably isn't important as of OpenBSD 4.8 because disklabel
# now ignores geometry specified by -R command.  Simply flashrd
# as much as possible in this regard. XXX
#
c 2 cat >> $NewLabel <<-EOF
	type: ESDI
	bytes/sector: $bytessec
	sectors/track: $sectorstrack
	tracks/cylinder: $trackscylinder
	sectors/cylinder: $sectorscylinder
	cylinders: $cylinders
	total sectors: $totalsize

	a: $asize   $sectorstrack   4.2BSD  1024    8192    16
	c: $totalsize 0 unused 0 0
	EOF

if [ -z "$alt" ]; then
 echo
 echo Creating new image...
 c 2 dd if=/dev/zero bs=$bytessec count=$bytessec of=$NewImg >/dev/null

 c 2 vnconfig $device $NewImg
fi

c 3 fdisk -c $cylinders -h $trackscylinder -s $sectorstrack -f /usr/mdec/mbr \
  -e $device <<-__EOC >/dev/null
	reinit
	update
	write
	quit
	__EOC

echo
echo Writing flashrd disklabel...
c 3 disklabel -R $device $NewLabel

echo
echo Creating new filesystem...
c 3 newfs -S $bytessec -q /dev/r"$device"a

c 3 mount -o async /dev/"$device"a $NewDir

UsedBlocks=`c 3 df $OldDir | tail -1 | awk ' { print $3 } '`
FreeBlocks=`c 3 df $NewDir | tail -1 | awk ' { print $4 } '`

if [ "$FreeBlocks" -le "$UsedBlocks" ]; then
  cat <<-__UsedBlocks

	Binaries use $((UsedBlocks / 1024 / (1024 / bytessec)))MB but only
	$((FreeBlocks / 1024 / (1024 / bytessec)))MB available for hip-hop
	verbal potential.  Sorry, you must specify a larger destination size.
	__UsedBlocks
 4; 3; 2; 1; 0;
fi

echo
echo Copying installation...
c 4 tar cf - -C $OldDir . | tar xpf - -C $NewDir

echo
echo Installing boot blocks...
c 4 installboot -r $NewDir $device

echo
echo Checking filesystem...
c 4 fsck -f /dev/"$device"a

umountwait 4 /dev/"$device"a
umountwait 3 /dev/"$rootdevice"a

if [ -z "$alt" ]; then
 c 1 vnconfig -u $device
fi
c 0 vnuncfgroot

if [ "$bytessec" -le 1024 ]; then
 new="$((totalsize / 1024 / (1024 / bytessec)))MB "
fi
echo
echo Grow completed.
if [ -z "$alt" ]; then
 echo New "$new"image is located at $NewImg
else
 echo "New image written to ${device}(${alt})"
fi
echo

rmdir $NewDir $OldDir
rm $NewLabel

exit 0
